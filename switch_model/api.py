"""
Provide an API for getting information about models. Mainly used by Switch
Electron/Theia/VSCode app.

Info can be retrieved by running `switch <cmd> <args> --json` from
Switch.app. This will launch the bundled switch.py script, which will write the
required info to stdout. But if needed we could create an RPC interface for
switch.py to avoid reloading Python each time. Commands and arguments are shown
below.

`validate arguments` (maybe): check whether there are any arguments in
options.txt that aren't defined in any active module

`validate modules` (maybe): confirm all are available or identify unsound ones. also
minimally reorder modules based on their declared dependencies, to ensure they
will run successfully. Add missing modules based on declared mandatory
dependencies. Identify conflicting modules based on declared conflicts.

`validate inputs` (maybe): check for inconsistencies in data files based on
rules derived from code possibly via documentation framework. check for missing
data needed by current modules. report cases where extra data will be ignored.
report missing optional columns.
"""

import importlib, os, pprint, json

import switch_model
from .utilities import unwrap, _ArgumentParser  # includes some extra actions for Switch

argparser = _ArgumentParser()


def info():
    """
    `info --module-arguments <name>`:
    """

    # parse arguments
    argparser.add_argument(
        "--json",
        default=False,
        action="store_true",
        help="Report results as json text instead of prettified Python objects.",
    )
    argparser.add_argument(
        "--module-list",
        default=False,
        action="store_true",
        help=(
            "report all Switch modules (.py files with define_components "
            "functions inside) found in the Switch search path (given by "
            "`--module-search-path`)"
        ),
    )
    argparser.add_argument(
        "--module-arguments",
        default=None,
        dest="module",
        help=(
            "report all arguments defined by the specified module, including "
            "info about data type, single vs multiple, help text, etc."
        ),
    )
    options = argparser.parse_args()

    output = []
    # run steps
    if options.module_list:
        output.append(module_list())

    if options.module is not None:
        output.append(module_arguments(options.module))

    if len(output) == 1:
        output = output[0]

    # report results in json or plain text
    # print("info requested:")
    if options.json:
        print(json.dumps(output, indent=2))
    else:
        pprint.pprint(output)


def module_list():
    # TODO: sort these based on dependencies (using dependencies var if provided)
    # TODO: remove modules that are masked by modules with the same name earlier
    # in the search path

    # for now, only search in the working directory and switch_model directory
    # TODO: search in user-specified path (--module-search-path) and in site-packages
    # (in case they installed a switch add-on package of some sort)
    # Note: it is a bad idea to test the built-in modules, because that is slow
    # and has weird side effects (e.g., `import this`, some Tk demo code and
    # opening https://xkcd.com/353/ in the system browser)
    # note: the __path__variable of a package is a list, to show all the
    # locations its submodules can be found.

    paths = [(switch_model.__path__, "switch_model."), ([""], "")]
    avail_modules = []
    for path, prefix in paths:
        avail_modules.extend(find_switch_modules(path, prefix))

    return avail_modules


def find_switch_modules(path, prefix):
    """
    pre-cached/pre-sorted wrapper for pkgutil.walk_packages
    """
    if prefix == "switch_model.":
        # return pre-determined list of built-in modules to avoid walking the
        # tree more than necessary. This list can be regenerated by cd'ing
        # to the switch root directory (which puts switch_model into the search
        # path without a prefix), then running switch info --module-list and
        # keeping (and re-sorting) the second set of switch_model.* modules.
        return [
            # standard modules
            "switch_model.timescales",
            "switch_model.financials",
            "switch_model.balancing.load_zones",
            "switch_model.energy_sources.properties",
            "switch_model.generators.core.build",
            "switch_model.generators.core.dispatch",
            "switch_model.reporting",
            # either-or modules
            "switch_model.generators.core.no_commit",
            "switch_model.generators.core.commit.fuel_use",
            "switch_model.generators.core.commit.operate",
            "switch_model.energy_sources.fuel_costs.simple",
            "switch_model.energy_sources.fuel_costs.markets",
            # optional modules (ordering isn't generally important)
            "switch_model.transmission.transport.build",
            "switch_model.transmission.transport.dispatch",
            "switch_model.transmission.copperplate",
            "switch_model.transmission.local_td",
            "switch_model.generators.extensions.storage",
            "switch_model.generators.extensions.hydro_simple",
            "switch_model.generators.extensions.hydro_system",
            "switch_model.generators.core.gen_discrete_build",
            "switch_model.generators.core.commit.discrete",
            "switch_model.balancing.demand_response.simple",
            "switch_model.balancing.demand_response.iterative",
            "switch_model.balancing.demand_response.iterative.r_demand_system",
            "switch_model.balancing.operating_reserves.areas",
            "switch_model.balancing.operating_reserves.spinning_reserves",
            "switch_model.balancing.operating_reserves.spinning_reserves_advanced",
            "switch_model.balancing.planning_reserves",
            "switch_model.energy_sources.fuel_costs.markets_expansion",
            "switch_model.energy_sources.fuel_costs.simple_per_timepoint",
            "switch_model.policies.carbon_policies",
            "switch_model.policies.rps_simple",
            "switch_model.balancing.unserved_load",
            "switch_model.reporting.basic_exports",
            "switch_model.reporting.dump",
            "switch_model.balancing.diagnose_infeasibility",
            "switch_model.hawaii.hydrogen",
            "switch_model.hawaii.ev",
            "switch_model.hawaii.ev_advanced",
            "switch_model.hawaii.rps",
            "switch_model.hawaii.fed_subsidies",
            "switch_model.hawaii.smooth_dispatch",
            "switch_model.hawaii.save_results",
            "switch_model.hawaii.demand_response_simple",
            "switch_model.hawaii.emission_rules",
            "switch_model.hawaii.fuel_markets_expansion",
            "switch_model.hawaii.heco_outlook_2019",
            "switch_model.hawaii.heco_outlook_2020_06",
            "switch_model.hawaii.heco_outlook_2020_08",
            "switch_model.hawaii.heco_plan_2020_06",
            "switch_model.hawaii.heco_plan_2020_08",
            "switch_model.hawaii.hi_spinning_reserves",
            "switch_model.hawaii.lake_wilson",
            "switch_model.hawaii.lng_conversion",
            "switch_model.hawaii.no_central_pv",
            "switch_model.hawaii.no_onshore_wind",
            "switch_model.hawaii.no_renewables",
            "switch_model.hawaii.no_wind",
            "switch_model.hawaii.oahu_plants",
            "switch_model.hawaii.psip_2016_04",
            "switch_model.hawaii.psip_2016_12",
            "switch_model.hawaii.pumped_hydro",
            "switch_model.hawaii.register_hi_storage_reserves",
            "switch_model.hawaii.reserves",
            "switch_model.hawaii.smooth_dispatch_quadratic",
            "switch_model.hawaii.switch_patch",
            "switch_model.hawaii.unserved_load",
        ]
    else:
        # lookup available packages
        import pkgutil

        switch_callbacks = [
            "define_arguments",
            "define_components",
            "define_dynamic_components",
            "load_inputs",
            "pre_solve",
            "pre_iterate",
            "post_iterate",
            "post_solve",
        ]
        avail_modules = []

        for info in pkgutil.walk_packages(path=path, prefix=prefix):
            try:
                mod = importlib.import_module(info.name)
                if any(hasattr(mod, x) for x in switch_callbacks):
                    avail_modules.append(info.name)
            except:
                # some kind of error, skip
                pass
        return avail_modules


def arg_dict(arg, *ops):
    action = arg.__class__.__name__.strip("_")
    if action.endswith("Action"):
        action = action[:-6]
    result = {}
    for flag in arg.option_strings:
        if flag + "s" in arg.option_strings:
            # skip single version of flags when there are duplicate single/plural
            # (e.g., --save-expression and --save-expressions)
            continue
        d = result[flag] = dict()
        d["action"] = action
        for op in ops + ("nargs", "default", "choices", "help"):
            d[op] = getattr(arg, op)
        # help text may be linewrapped, which Python automatically cleans up
        d["help"] = unwrap(d["help"])
    return result


def module_arguments(module):
    import argparse as ap

    result = dict()

    mod = importlib.import_module(module)  # or sys.modules[module]

    if hasattr(mod, "define_arguments"):
        mod_parser = _ArgumentParser()
        mod.define_arguments(mod_parser)
        for arg in mod_parser._actions:
            if isinstance(arg, ap._HelpAction):
                # skip the default --help option
                continue
            else:
                result.update(arg_dict(arg))

    return result
